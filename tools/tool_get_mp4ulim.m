## Get array of upper sample index limits to render MP4 video files#### This function is used to restrict the number of samples of a signal. This enables a more meaningful representation of the signal for ## the automated creation of MP4 video files. The upper index limit is used to cutting off the right side of the signal which mainly## consists of noise.#### FUNCTION SYNOPSIS:#### Usage 1: [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, p_tf, p_ws, p_es)##                     non-interactive mode#### Usage 2: [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, p_tf, p_ws, [])##          [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, p_tf, p_ws)##                     non-interactive mode##                     do not extend upper limit (p_es = 0)#### Usage 3: [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, p_tf, [], p_es)##                     non-interactive mode##                     use default filter window size (boxcar filter, p_ws = 3)#### Usage 4: [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, [], p_ws)##                     non-interactive mode##                     threshold factor is set to default value (p_tf = 0.1)#### Usage 5: [r_ul] = tool_get_mp4ulim(p_ds, p_cn, [], p_tf)##                     non-interactive mode##                     number of signals is set to default value (p_ns = 5)#### p_ds ... dataset data structure or ultrasonic test substructure, <struct_dataset> or <struct_test_utt>## p_cn ... channel number, <uint>##            0: channel is already selected, p_ds is a ultrasonic test substructure <struct_test_utt>##            1: channel 1, compression wave, longitudinal##            2: channel 2, shear wave, transversal##            3: channel 1 and 2, used for combined plots## p_ns ... number of signals, optional, default = 5, <uint>## p_tf ... threshold factor, optional, default = 0.1, <dbl>## p_ws ... filter window size, number of samples, optional, default = 3, <uint>## p_es ... upper limit extension, number of samples, optional, default = 0, <uint>## r_ul ... return: array of upper sample index limits, [<uint>]#### see also: dsviewer_mp4.m#### Copyright 2023 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)## License: MIT## This file is part of the PhD thesis of Jakob Harden.## ## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated ## documentation files (the “Software”), to deal in the Software without restriction, including without ## limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of ## the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:## ## THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ## THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, ## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.##function [r_ul] = tool_get_mp4ulim(p_ds, p_cn, p_ns, p_tf, p_ws, p_es)    ## check arguments  if (nargin < 4)    p_tf = 0.1;  endif  if (nargin < 3)    p_ns = 5;  endif  if (nargin < 2)    help tool_get_mp4ulim;    error('Less arguments given!');  endif    ## switch channel  switch (p_cn)    case 0      ## channel is already selected (see also dsviewer_mp4.m)      ms = p_ds.d13.v;      i0 = p_ds.d09.v + 100;    case 1      ## channel 1, compression wave      ms = p_ds.tst.s06.d13.v;      i0 = p_ds.tst.s06.d09.v + 100;    case 2      ## channel 2, shear wave      ms = p_ds.tst.s07.d13.v;      i0 = p_ds.tst.s07.d09.v + 100;    otherwise      help tool_get_mp4ulim;      error('Selected channel number %d is not defined!', p_cn);  endswitch    ## set first part of signal to zero  ms(1:i0, :) = 0.0;    ## absulute values of magnitudes  ms = abs(ms);    ## number of samples  nsmp = size(ms, 1);    ## number of signals  nsig = size(ms, 2);    ## check number of signals  ## return constant valued array for small signal series (reference tests)  if (nsig <= 20)    ## feature vector    vec = mean(ms, 2);    ## find sample index where magnitude exceeds threshold value (maximum of feature vector time threshold factor)    ulidx = find(vec > (p_tf * max(vec)), 1, 'last');    ## init return value    r_ul = ones(nsig, 1) * ulidx;    return;  endif      ## init limit array  ul = ones(nsig, 1) * nsmp;
    ## iterate over signal series (descend)  for i = nsig : -1 : p_ns    ## sample index range    sig_rng = [(i - p_ns + 1) : i];    ## feature vector    vec = mean(ms(:, sig_rng), 2);    ## find sample index where magnitude exceeds threshold value (maximum of feature vector time threshold factor)    ulidx = find(vec > (p_tf * max(vec)), 1, 'last');    ## check signal index    if (i == nsig)      ## define first result as absolute minimum of return values      ulidx0 = ulidx;      ul(i) = ulidx0;    else      ## accept only results that satisfy the following two conditions:      ## condition 1: limit >= last limit (i = nsig, ul(nsig))      ## condition 2: limit >= previous limit (i+1, ul(i+1))      ul(i) = max([ulidx, ul(nsig), ul(i+1)]);
    endif
  endfor    ## extend upper limits  if (p_es > 0) && (p_es < 1000)    ## extend    ul = ul + p_es;    ## restriuct extension to max. number of samples    ul(ul > nsmp) = nsmp;  endif
    ## filter results  if (p_ws == 0)    ## no filtering    r_ul = ul;  else    ## apply simple boxcar filter on results    ulf = [ul; ones(p_ws - 1, 1) * ul(end)];    r_ul = zeros(nsig, 1);    for i = 1 : nsig      r_ul(i) = fix(mean(ulf(i : (i + p_ws - 1))));    endfor  endif
  endfunction